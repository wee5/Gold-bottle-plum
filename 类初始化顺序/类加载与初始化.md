# 类加载与初始化，对象实例化

* **原则：同种变量中，变量定义顺序决定初始化顺序。不同变量中，先静态后非静态**，主方法在静态与非静态之间
  * 分析类加载顺序时：将代码按加载顺序梳理一遍，而非代码格式顺序

* **加载——链接（验证，准备，解析）——初始化——使用，卸载**
  * 加载：通过类加载器将Class文件（二进制文件）加载到jvm中
  * 验证：验证Class文件，主要为安全考虑
  * 准备：为静态属性分配内存并赋值为默认值
  * 解析：将符号引用解析为直接引用
  * 初始化：为静态变量赋值正确的值，执行静态代码块
* **类加载**：加载，链接，初始化
  * 类加载：jvm将java文件编译成class文件后，
    * **通过类的全限定名来获取定义此类的二进制流**
    * **将字节流所代表的静态存储结构转化为方法区的运行时数据结构**
    * **在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口**
    * 简单说：**由Class文件，将类加载入内存**

## 类加载的时机

* 类的**主动**使用会加载类
  * **读取类/接口的静态属性，调用静态方法（读取final修饰的复杂类型）**
  * **初始化子类，父类会先被初始化**
  * **读取静态内部类的静态属性，初始化外部类**
  * **执行主方法，包含主方法的类会先加载**
  * 命令行启动应用，由JVM初始化加载
  * 通过Class.forName()方法动态加载，即反射类
  * 通过ClassLoader.loadClass()方法动态加载
* 类的**被动**使用不会加载类
  * 子类引用父类静态属性，父类初始化，子类不会初始化
  * 通过引用类型定义数组，不会触发该类初始化
  * 读取**final修饰的常量不会触发该类初始化**，因为在编译期就放入了常量池
  * 读取**final修饰的复杂类型，会触发该类初始化（应为加载，按照本篇加载和初始化理解）**，因为在编译期不会计算出该值
  * JVM最初初始化的总是java.lang.Object类

## 加载，初始化，实例化（个人理解）

* **加载**：静态部分分配内存，**先顺序赋默认值，再重新赋值**
* **初始化**：非静态部分分配内存，赋默认值，再重新赋值
* **实例化**：先加载，再初始化
* 静态部分属于类，非静态部分属于对象
* final常量在编译器赋值，final引用类型在编译器预留ConstantValue
* 同一个类中，静态内容>主方法>非静态内容

## 父子类

* 初始化子类时，父类先被初始化
* 子类引用父类静态属性，父类初始化，子类不会初始化

## 内部类

* 非静态内部类
  * 非静态内部类实例化时，外部类会先初始化
  * 非静态内部类不能包含静态内容
  * 实例化非静态内部类：new Outer().new Inner()
* 静态内部类（和外部类没什么关系，相当于写在外面的类）
  * 静态内部类实例化时，外部类不执行
  * 实例化静态内部类：new Outer.StaticInner()，
* 外部类加载时，内部类不会执行

## 加载顺序汇总

* **编译**期：final常量被赋值，final引用类型预留ConstantValue
* 找**主方法**，遵守原则：**静态内容>主方法>非静态内容**
* **加载**
  * **静态属性**和**静态代码块**按顺序分配内存
  * 静态属性赋**默认值**，静态代码块**内容不执行**
  * 静态属性**赋值**，静态代码块**内容执行**
* **初始化**
  * 静态部分在第一次加载后不处理
  * 非静态属性
  * 构造代码块
  * 构造方法
* **实例化**：包含以上全过程

## 类下代码归类（按执行顺序）

* **静态内容**：静态属性，静态代码块
* **主方法**
* **非静态内容**：非静态属性，构造代码块，构造方法
* **方法**：静态方法，非静态方法

## 补充

* **全篇将加载和初始化分开，实例化分为加载初始化；也可将加载和初始化作统一意思，实例化变为原来的初始化**
* **本篇最大疑问，在于加载和初始化的理解；和final修饰的常量，复杂类型，非常量普通类型（String，boolean）**
* 静态代码块中，可以读取和写入前面的静态变量，可以读取但不能写入后面定义的静态变量
* 静态内容只会加载一次