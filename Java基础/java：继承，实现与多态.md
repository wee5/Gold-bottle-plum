# java：继承，实现与多态

## 类和对象

* 类像模板一样，可以根据模板创建对象
* 类**规定**了变量和方法，对象是一个实例，会拥有类规定的变量和方法



## 父类和子类

* 好处：
  * 父类是为了减少**代码冗余**
  * 将经常出现的变量和方法归位一类
  * 通过继承，继承父类变量和方法，并且子类可以有自己的变量和方法
* **继承和多态**
  * 继承是一种类的关系
  * 多态是一种运用，直观体现是代码写法，多态的前提是继承
  * **子类继承的规则**
    * **在继承前提下，无论是否运用多态；不是重名变量或方法（即重写）时，子类继承父类（除private修饰的）所有变量和方法；重名时，变量看申明，虚方法看实例化，实方法不会重名**
    * 原因（重名变量和方法时）：
      * **成员变量静态绑定**，编译时绑定；即申明的子类，实例化子类时，变量空间开辟为子类变量
      * 成员方法看是不是虚方法；由final，static，private等修饰的不是虚方法，在编译时绑定，因为其地址是确定的；**虚方法是动态绑定的**，根据实例化的类开辟方法地址
  * **设计继承关系的类时**
    * 单纯继承关系：子类继承所有非私有化的变量和方法；重名时，子类覆盖父类变量和方法
    * 多态关系：子类继承所有非私有化的变量和方法；重名时，父类覆盖子类变量，子类覆盖父类方法（即方法重写）

## 抽象类

* 介于父类和接口的中间体

* **抽象类：**
  * 抽象类**仅可以**包含抽象方法；任何类都可以改为抽象类，但是抽象类不一定能改为非抽象类
  * 抽象类不能被实例化；抽象类只能被继承；可以由子类和抽象子类继承
  * 抽象方法无方法体，必须由子类重写；或由抽象子类直接继承，而不用重写



## 接口类

* 什么是接口类

  * 接口类无方法体，规定了方法的方法名，返回类型，参数类型和参数数量；接口类不能实例化

* 接口类的作用

  * **确定类型，但不确定方法体**

* 接口类应用

  * ```java
    interface Animal
        
    class Dog implements Animal
    
    Animal some=new Dog();//多态
    /*
    some只是变量名，一个指向；同时some也是一个实例
    some的类型为Animal，它的属性和方法由实现类Dog实现，包括变量，重写方法，和特有方法（即Dog的所有内容）
    */
    ```

* 接口在jdk中的应用

  * ```java
    interface Runnable
        
    class Mythread implements Runnable	//为什么java中总出现需要必须实现某个接口才可以用，看下面
    	@Override
        run（）{}；//重写run方法
        
    Runnable runnable=new MyThread();//多态，用实现类实例化接口
    runnable.start();//以多线程方式执行
    
    class.method(Runnable runnable)
    /*
    假设jdk中有某一个类的某一个方法，参数为Runnable类型，这是jdk预先写好的
    jdk将Runnable作接口，而不是类
    因为方法体不能确定，不能预先知道线程中要执行什么
    所以让开发者去实现Runnable接口，需要执行什么，重写的run方法里就写什么
    即jdk在预先编写好工具时，不知道开发者的具体使用类，于是利用接口实现机制，确定类型，方法名，参数和返回值，其他工具需要时使用接口类，而具体实现方法，让开发者编写，然后实现接口，再利用多态
    */
    ```

    





* 规定方法（方法名，返回值，参数），不包含方法体
* 好处：在程序中可能预置调用某个类的方法，即类需要程序员设计，但是方法名是固定的，如实现runable接口